## TCP三次握手
TCP 的三次握手，也是需要确认双方的两样能力: **发送的能力**和**接收的能力**。
![TCP三次握手](../img/Bowser/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

- 刚开始处于CLOSED（关闭状态），然后服务端开始监听某个端口进入LISTEN状态
- 第一次握手
  - 客户端开始主动发起连接，发送**SYN包（seq=x）**，自己变成**SYN-SENT（发送**）状态。
- 第二次握手
  - 服务器接收到SYN包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（Seq=y），即SYN + ACK包，此时服务器进入到**SYN-RCVD**状态（接受状态）
- 第三次握手
  - 客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

从图中可以看出，SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加1，为什么呢？
> 因为凡是需要对端确认的，一定消耗TCP报文的序列号。
> SYN 需要对端的确认， 而 ACK 并不需要，因此 SYN 消耗一个序列号而 ACK 不需要

- **ACK：确认号，期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。**
- **RST：重置连接**
- **SYN：用户初始化一个连接的序列号**
- **FIN：告诉对方结束发送数据**


**问题：为什么是三次，两次行不行，四次呢？**

根本原因: 无法确认客户端的接收能力。

如果是两次，客户端发送了SYN包想要建立连接，但是因为网络问题，这个包滞留在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。

但是连接关闭后，如果这个滞留在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认建立连接，但是现在客户端已经断开了。这就带来了连接资源的浪费。