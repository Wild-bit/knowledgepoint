## 什么是闭包？

> 闭包：闭包是指有权访问另一个函数的作用域中的变量的函数

## 如何产生闭包

> 创建闭包的常见方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包突破作用域链

## 闭包的特性

- 函数内在嵌套函数
- 内部函数可以引用外部函数的参数和变量
- 参数和变量不会被垃圾回收机制回收

### 参数和变量不会被垃圾回收机制回收
对于全局变量来说，全局变量的声明周期是永久的，除非主动销毁该变量（xxx = null）,但对于函数内部声明的变量来说，当函数退出时，这些变量会随着函数调用的结束而被销毁

现在来看看这段代码：
```js
const func = function(){
  let a = 0
  return function(){
    a++
    console.log('a:',a)
  }
}
const f = func()
f() // 输出 a:1
f() // 输出 a:2
f() // 输出 a:3
f() // 输出 a:4
```
按之前的理论，局部变量a在退出函数的时候就被销毁了，而代码中的a并没有被销毁，这是因为当执行 **const f = func()** 的时候，f返回了匿名函数的引用，它可以访问func()函数作用域，而局部变量a在func()的作用域内。既然局部变量还能被外部访问，垃圾回收就不会标记它，自然也就不会被销毁。这里产生了闭包的结构，延续了局部变量的生命周期。


## 为什么闭包的参数和变量不会被垃圾回收机制回收

> 因为js的垃圾回收机制是清理，那些没有被引用到的值，JavaScript 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除那些不可访问的对象。

例如：

```js   
function createIncrementor(start) {
  return function () {
    return start++;
  };
}

var inc = createIncrementor(5);

inc() // 5
inc() // 6
inc() // 7
```
通过闭包，start的状态被保留了，闭包（上例的inc）用到了外层变量（start），导致外层函数（createIncrementor）不能从内存释放
只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始终保存着当前值，供闭包读取，所以闭包inc使得函数createIncrementor的内部环境，一直存在